5-6
=========



demo
--------
我发现暂时只要这点需求就行了。。接下来的需求要在做demo中发掘。或者实际操作中寻找

做demo的时候发现模板的id，model，还有显示div的id应该是绑在一起的。他们可以被互相获取

但是应该谁是key呢？

1. model不能是key，因为他是一个hash了

2. 模板id不能是key，因为用模板id来获取model想想觉不对。

3. 显示div的id也不能是key。同理，

所以key只能vm，它包含3个子key： 

+ model
+ view（显示div的id）
+ viewmodel（模板id）

可能的动作貌似就两种

model + viewmodel => view(生成内容, model改变view)

view ==> model(view改变model)

所以就用一个对象表示，如：

		weakObserve({
			model: myModel,
			view: 'myView',
			vm: 'myvm'
		});

但问题又来了，当model修改的使用，我们应该知道数据被修改了。需要加上回调

回调的参数是什么呢？首先肯定是e(event)，其次还要有model，vm，view这些信息，还要能调用update这些函数！

所以e是一个大对象那些update函数都能放在e的prototype中

demo1：嵌套表单显示

demo2：列表的增删改(Hosts)

demo2问题：没有摆脱dom操作，增加view就是dom操作,除非是重新渲染

demo3: 实时更新

demo4: todo-list

data-bind出现问题
--------
使用data-bind的话，由于浏览器是用name作为radio唯一判断的，使用data-bind将还必须写上name。这完全是多此一举。

所以我觉得不如直接用name。。比起data-bind还能少写几个单词。

本来不用name是担心占用使用form的同学的属性。现在想想既然用了model，基本都是ajax的吧。占了就占了

updateModel函数
--------------
这个函数要做的就是把
1. 把person1.firstname 改掉
2. 如果是数组怎么办?

 >+ 首先这个数组每个都应该是可以改动的。所以name必须精确到i
 >+ 有数组的pop，push，shift，unshift功能

先考虑用的最多的push。就是添加一项，这已经很复杂了。

如果以前的话，我必须专门记录目前数组的长度，然后使用length+1来做name做出这个元素。

不过在mvvm中应该有的体验是直接对这个数组发送push。

但是如何产生和上面一样的view呢？

如果笨点的话我们只能重写一遍，但只要是重写，我们就知道已经错了，可以重构到没有重复代码

鉴于我发现毕竟我的html模板是string而不是dom，无法查找原来的。所以貌似只能重写了

完成updateModel()，我觉得非常完美

如何用modelUpdate来push数组
----------
push数组的常用程度堪比修改input

我们希望的方法是
arr2json({
	method: 'push',
	arr: [person1, hosts],
	val: {sth},
	json: model	
})
这样的意思很明显，就是向json[arr]中push元素val

完成了这个，非常完美


重要方法
-----------
model2view
----------
model转view非常简单，就是模板文件用model来渲染，生成view。

view2model
--------
这个是难点。方法有两种，一种是暴露在公有属性中（如knockout）
如
    <input type="text" data-bind="name.firstname" value="<%=name.firstname%>"></input>

这样的缺点是暴露逻辑，且每次都写出重复代码，并且很难将data-bind的值转为key。

重复代码的问题可以用正则解决。

另一种是将html模板转为dom,就是用appendChild而不是innerHTML来改变view。

但是我没有搞清楚原理

因此暂且用第一种，data-bind的方式（很显然这种会使老的浏览器不兼容）

要注意的是，只有需要读取数据的元素才要data-bind

    <span><%=(firstname+lastname)%></span>

这是不需要data-bind的，因为不会从这里面取数据。

非常不幸的是，即便知道修改的key和目前的value，我们依然不知道是修改了哪个model的value

因此还需要model与view绑定的函数,比如model的名字等于view的id

等等。还有一个问题出现了，修改input中的值，也就修改了model，如果整个view都重新渲染了，那会不会每次输入字符都要闪一次？

看看knockout就知道，他分成两种类型,value和text。一种是可以改变model的，另一种是只被model影响而修改

为了先作出个样子，使用弱观察,即addEventListener('change')，这个类似blur，这样的话渲染整个view也没事了。





